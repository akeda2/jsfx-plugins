// JSFX-CookDSP - Pobjects example
// (c) Olivier Belanger - 2015 - belangeo@gmail.com

desc:Polyphonic Midi Granulator

import cookdsp.jsfx-inc

slider1:24<1,64,1>Number Of Grains
slider2:1<0.125,4>Transposition
slider3:0.5<0,1>Reading Position
slider4:0.1<0.01,0.5>Grain Duration
slider5:0.1<0,1>Random Transposition
slider6:0.1<0,1>Random Position
slider7:0<0,1,1{Playing,Recording}>Play/Record Mode

slider11:5000<100,5000>Lowpass Filter Cutoff Frequency
slider12:5<1,25>Lowpass Filter Q

slider13:0.01<0.001,1>Attack Time
slider14:1<0.01,10>Release Time

@init
// Number of voices
VOICES = 2;
// Sets an array to hold output values
outs = set(VOICES, 0);
// Sets an array to hold amplitude values
amps = set(VOICES, 0);
// Sets an array to hold oscillator frequencies
freqs = set(VOICES,0);
// Initializes VOICES envelopes
envs.Pmasr(set(VOICES, slider13), set(VOICES, slider14));
// Initializes VOICES oscillators
grL.Pgrains(set(VOICES,slider1), set(VOICES,slider2), set(VOICES,slider3), set(VOICES,slider4), set(VOICES,slider5), set(VOICES,slider6),set(VOICES,10));
//phs.Pphasor(freqs, set(VOICES,0));
// Resonant lowpass filter
lp.biquad(slider11, slider12, 0);
// Initializes the MIDI polyphony manager
p.poly(2, 1);

//bufL = grL.grains(slider1, slider2, slider3, slider4, slider5, slider6, 10);
//bufR = grR.grains(slider1, slider2, slider3, slider4, slider5, slider6, 10);

@slider
// Sets lowpass filter parameters
lp.biquad_set_freq(slider11);
lp.biquad_set_q(slider12);

// Sets all parameters at once.
//grL.grains_set(slider1, slider2, slider3, slider4, slider5, slider6);
//grR.grains_set(slider1, slider2, slider3, slider4, slider5, slider6);
// We need to record some samples in memory to be able to granulate them.
grL.Pgrains_record(set(VOICES,slider7));
//grL.Pgrains_set_pos(set(VOICES,slider3));
//grL.Pgrains_set_dur(set(VOICES,slider4));
grL.Pgrains_set(set(VOICES,slider1), set(VOICES,slider2), set(VOICES,slider3), set(VOICES,slider4), set(VOICES,slider5), set(VOICES,slider6));
//grR.grains_record(slider7);

//envs.Pmasr_set_risetime(set(VOICES, slider13));
//envs.Pmasr_set_falltime(set(VOICES, slider14));

@block
// Until all midi events have been processed
while (n.notein()) (
    // If midi event is a midi note
    n.ok ? (
        p.poly_do(n.pitch, n.velocity);
        // If a voice has been assigned
        p.voice != -1 ? (
            // Sets the frequency for the voice
            freqs[p.voice+1] = mtot(p.pitch,60);
            grL.Pgrains_set_pitch(freqs);
            //grR.grains_set_pitch(freqs);
            //grL.Pgrains_set_pos(set(VOICES,slider3));
            //grL.Pgrains_set(set(VOICES,slider1), set(VOICES,slider2), set(VOICES,slider3), set(VOICES,slider4), set(VOICES,slider5), set(VOICES,slider6));
            
            //phs.Pphasor_set_freq(freqs);
            // Sets the amplitude for the voice
            amps[p.voice+1] = p.velocity / 127;
        );
    );
);

@sample
// Computes the envelopes
gains = envs.Pmasr_do(amps);
input = (spl0+spl1)*0.5;
// Computes the oscillators
//play_state == 1 ? (
waves = grL.Pgrains_do(set(VOICES,input));
//);
//phs.Pphasor_do();
// Applies envelopes to oscillators
k = 1;
while (k <= VOICES) (
    outs[k] = gains[k] * waves[k]; 
    k += 1; 
);
// Monophonic summation
outsig = sumchnls(1, outs);
// Lowpass filter and output
spl0 = spl1 = lp.biquad_do(outsig[0]) * 0.2;

//play_state == 1 ? (
  //      spl0 = grL.grains_do(spl0); 
    //    spl1 = grR.grains_do(spl1);
    //);

